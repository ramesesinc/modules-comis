import com.rameses.annotations.*
import com.rameses.services.extended.*

class ComisApplicationService {
    @Env 
    def env;
    
    @Service('DateService')
    def dtSvc;

    @Service('SequenceService')
    def seqSvc;

    @Service('ReportParameterService')
    def reportSvc;

    @Service('ComisApplicationRuleService')
    def ruleSvc;

    @Service("WorkflowTaskService")
	def wfSvc;

    @DataContext('application')
    def em_app;

    @DataContext('application_task')
    def em_task;

    @DataContext('relation')
    def em_relation;

    @DataContext('deceased')
    def em_deceased;

    @DataContext('cemetery_resource')
    def em_cem_resource;

    @DataContext('payment')
    def em_payment;

    @DataContext('permit')
    def em_permit;

    
    def STATE_DRAFT = 'DRAFT';
    def STATE_FORPAYMENT = 'FORPAYMENT';
    def STATE_FORRELEASE = 'FORRELEASE';
    def STATE_ACTIVE = 'ACTIVE';
    def STATE_EXPIRED = 'EXPIRED';
    def STATE_RENEWED = 'RENEWED';
    def STATE_APPROVED = 'APPROVED';

    @ProxyMethod
    public def getRelations() {
        return em_relation.find([state: 'ACTIVE']).orderBy('title').list();
    }

    @ProxyMethod
    public def create() {
        def pdate = dtSvc.parseCurrentDate();
        def app = [:];
        app.state = 'DRAFT';
        app.online = true;
        app.apptype = 'NEW';
        app.dtapplied = pdate.date;
        app.appyear = pdate.year;
        app.renewable = true;
        app.leaseduration = 0;
        app.amount = 0;
        app.amtpaid = 0;
        app.balance = 0;
        setLessor(app);
        app.lessee = [:];
        app.deceased = createDeceased(app);
        app = em_app.create(app);
        startWorkflow(app);
        return app;
    }

    @ProxyMethod
    public def renew(param) {
        def prevapp = em_app.read(param.prevapp);
        if (!prevapp) throw new Exception('Application does not exist or has already been deleted.');

        def app = [:];
        app.state = 'DRAFT';
        app.apptype = 'RENEWAL';
        app.online = true;
        app.dtapplied = dtSvc.serverDate;
        app.appyear = dtSvc.serverYear;
        app.applicant = param.applicant;
        app.relation = param.relation;
        app.resourceinfo = prevapp.resourceinfo;
        app.leaseduration = prevapp.leaseduration;
        app.deceased = prevapp.deceased;
        app.amount = 0;
        app.amtpaid = 0;
        app.renewable = true;
        setLessor(app);
        app.lessee = [:];
        app.prevappid = prevapp.objid;
        app = em_app.create(app);
        startWorkflow(app);
        return app;
    }

    @ProxyMethod
    public void beforeDelete(app) {
        app = em_app.select('objid,deceased.objid').find([objid: app.objid]).first()
        em_cem_resource.find([currentappid: app.objid]).update([currentappid: '{NULL}']);
        em_task.find([refid: app.objid]).delete();
        em_app.find([objid: app.objid]).update([deceased_objid: '{NULL}'])
        em_deceased.find([objid: app.deceased.objid]).delete();
    }

    @ProxyMethod
    public def approve(entity) {
        def app = em_app.read(entity);

        if (app.state != STATE_DRAFT) 
        throw new Exception('Unable to approve application. Only draft application is allowed.');

        if (app.online == 1 || app.online) {
            entity.appno = getNextSeries('BURIAL-PERMIT-APP')
            entity.dtapproved = dtSvc.serverDate;
            entity.state = STATE_FORPAYMENT;
        } else {
            entity.state = STATE_ACTIVE;
            def task = signalWf(app, 'active');
            entity.taskid = task.taskid;
        }
        em_app.update(entity);
        em_app.find([objid: app.prevappid]).update([state: STATE_RENEWED]);
        em_cem_resource.find([objid: app.resourceinfo.parentid]).update([currentappid: entity.objid]);
        em_deceased.find([objid: app.deceased.objid]).update([state: STATE_APPROVED]);
        return entity;
    }

    @ProxyMethod
    public def release(entity) {
        def old = em_app.read(entity);

        if (old.state != STATE_FORRELEASE) 
        throw new Exception('Unable to release application. Only for release application is allowed.');

        entity.state = STATE_ACTIVE;
        em_app.find([objid: entity.objid]).update([state: entity.state]);
        return entity;
    }

    @ProxyMethod
    public def  postCapturePayment(payment) {
        payment.txndate = dtSvc.serverDate;
        payment = em_payment.create(payment);
        em_app.find([objid: payment.appid]).update([amtpaid: payment.amount]);
        return payment;
    }


    void startWorkflow(app) {
        def task = [:];
        task.processname = 'application';
        task.refid = app.objid;
        task.startdate = dtSvc.getServerDate();
        task.info = app;
        task.assignee = [objid:env.USERID, name:env.FULLNAME];		
        wfSvc.start(task);			
    }

    def getNextSeries(prefix) {
        def cy = dtSvc.serverYear;
        def keyid = prefix + '-' + cy;
        def series = seqSvc.getNextFormattedSeries(keyid);
        return cy + '' + series;
    }

    def createDeceased(app) {
        def deceased = [:];
        deceased.state = 'DRAFT';
        deceased.nationality = 'FILIPINO';
        return em_deceased.create(deceased);
    }

    def signalWf(app, action) {
        def task = [:];
        task.refid = app.objid;
        task.state = action;
        task.dtcreated = app.dtapproved;
        return em_task.create(task);
    }

    void setLessor(app) {
        def params = reportSvc.getStandardParameter();
        app.lessor = [:];
        app.lessor.name = params.MAYORNAME;
        app.lessor.title = params.MAYORTITLE;
        app.lessor.ctcplaceissued = params.LGUADDRESS;
    }

}